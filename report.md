課題レポート
===============
xxx大学　xxx工学科
xx研究室　xxx年
xxxxx
<br />

１. データ概要
--------------
ユーザーが映画を評価するデータセット、その中：

ユーザーID: １〜９４３（合わて９４３名）
映画ID: １〜１６８２（合わて１６８２作）
映画種類: ０〜１８（合わて１９類。アクション、ホラー、ロマンスなどで種類分ける）

データは **配列(Array)** に整理しましたら、２つの配列にまとめます：
<br />

> １. $Array[ユーザーID][映画ID] \ ＝ \ 評価$

  * ユーザーをサンプル、各映画への評価は特徴量と見なす、$\textbf{R}^{943\times 1682}$ の行列です
  * この行列転置したら、映画をサンプル、各ユーザーの評価は特徴量の行列になります
  * 評価範囲は０〜５、評価低い〜評価高い: １〜５、０は評価なし
<br />

> ２. $Array[映画ID][種類番号] \ ＝ \ bool値$

  * $\textbf{R}^{1682\times 19}$ の行列です
  * 値１はこの種類に所属、０は所属していない。
<br />

２. 処理流れを
--------------
協調フィルタリングと関係モデルの思考で処理しました：

* 各ユーザーに対して、一部の映画を選択し、選択した映画を評価します。
最後に評価点数によって推薦する映画を決めます。

**具体的な手順**：
1. k-meansでユーザーたちをいくつのグルプに分けます。そしてグルプ分けの結果を保存します
2. 各ユーザーに対して、ユーザーが映画種類の好み度を計算します。そしてその結果を保存します。


3. 各ユーザーに対して、このユーザー見たことない、でも同じグルプの他のメンバーが見たこと映画を選び出す
4. グルプの中で、選び出す映画の評価の平均値を計算します。それを初期評価値にします。


5. 各選び出す映画に対して、映画の種類とユーザー自身の好みと合わせて重みを計算します。
6. 初期評価値を重みつけて、最終評価が得られます。
7. 最初評価をソートして、高い順番から推薦を行います。
<br />

３. 手法解説（問１）
--------------
>#### ３.１　k-means
* k-meansアルゴリズムはクラスタリング手法の一種、機械学習においては監督なし学習です。
  今回はユーザーをサンプル、映画の評価を特徴量にして、k-meansアルゴリズムを使ってユーザーをクラスタリングします：

**k-means の手順**：
1. ランダムでｋ個の中心点を生成する（今回は k=10 に設定しました）
2. 各データを自分と最も近い`[1]`中心点に割り当てる
3. 各中心点を自分に割り当てられたデータの中心に移動`[3]`する
そして２～３を繰り返す、データの所属がもう一度割り当てしても変わらない時、各中心点の位置は最終位置になって、グルプも決まります。

**[1]**．手順２と３距離の種類はたくさんあります。今回は（１－ピアソンの積率相関係数）`[2]`を距離にしました
**[2]**. ピアソンの積率相関係数の数式は $r=\dfrac{n\sum x_i y_i- \sum x_i \sum y_i}{\sqrt{n\sum x_i^2-(\sum x_i)^2}\sqrt{n\sum y_i^2-(\sum y_i)^2}}$ です

$x_iとy_i$ は二人のユーザーどっちでも見たことある映画の評価です
ピアソンの積率相関係数の良いどころは二人のユーザーの基準評価 (baseline rating) が違っても、得られた結果が同じです
ピアソンの積率相関係数の範囲は -1～1、-1は負相関、０は無関、１は相関
１－ピアソンの積率相関係数にしたら、数値範囲は ０～２になります、２は負相関、１は無関、０は相関。相関のとき距離は最も近いになります

**[3]**. ピアソンの積率相関係数を使っているため、中心に移動移動するとき、評価は０（評価なし）のサンプルは計算に参加しない。
（例えば、ある映画に対して、a, b, c三人の評価は 1, 5, 0 なら、中心を $(1+5)/2$ にします）

<br />
>#### ３.２　重み計算
映画の数を $M$ と表記します

映画$m$ の採点を $r_m$ と表記します

映画$m$ の種類ベクトルが $\textbf{C}_m=\textbf{R}^{1\times19}$ と表記します

ユーザー$u$ の好み度ベクトルが $\textbf{F}_u=\textbf{R}^{1\times19}$ と表記します

* **好み度ベクトルの計算**：

$\textbf{F}_u' = \sum\limits^{M}_{m=0}{\textbf{C}_m\times r_m}$ （ユーザーu にたいして、全ての映画種類ベクトルｘ評価 の和を計算します）

$\textbf{F}_u = \dfrac{\textbf{F}_u'}{\sum\limits^{19}_{i=0}f_i'}$　（ $\textbf{F}_u'$ を正規化したら好み度ベクトルになります。$f'$ は $\textbf{F}_u'$ の各成分です）

（正規化したあと $\sum f_i=1$）

そしてユーザー$u$ に対して映画$m$ の重みは $W_{um} = Sum(F_u \times C_m) = \sum\limits_{i=0}^{19}(f_{ui} \times c_{mi})$ です
***
* **重みの計算例**：

ユーザー **Yさん** は **映画A** と **映画B** を見ました。そして **Aを１点** 、**Bを４** 点で評価しました。

**映画A** の種類ベクトル $\textbf{C}_A = [0 \ 0 \ 1 \ 1]$ （簡単説明のため、種類を４種類にします）

**映画B** の種類ベクトル $\textbf{C}_B = [1 \ 1 \ 0 \ 0]$

そうしたら $\textbf{F}_Y' = 1\times\textbf{C}_A + 4\times\textbf{C}_B = 1\times[0 \ 0 \ 1 \ 1] + 4\times[1 \ 1 \ 0 \ 0] = [4 \ 4 \ 1 \ 1]$

**Yさん** の好み度ベクトル $\textbf{F}_Y = \dfrac{[4 \ 4 \ 1 \ 1]}{4+4+1+1} = [0.4 \ 0.4 \ 0.1 \ 0.1]$
<br />

そしてグルプから **映画D** を **3.5点の評価** で推薦されました

**映画D** の種類ベクトル $\textbf{C}_D = [0 \ 1 \ 1 \ 0]$

じゃ **Yさん** に対して、**映画D** の **重み付き評価** は

$Sum(\textbf{F}_Y\times\textbf{C}_D)\times3.5 = (0.4\times0 + 0.4\times1 + 0.1\times1 + 0.1\times1)\times3.5 = 0.5\times3.5 = 1.75$ です
***
<br />

４. 考察（問２）
--------------
>#### 改善点

* k-means：

1. 中心点の初期値の影響が大きい、中心点の初期値が悪い時結果も悪くなります。
それを改善するk-means++がありますが、距離はノルム距離（マンハッタン距離や、ユークリッド距離とか）以外の時（今回のピアソンの積率相関係数のように）の実装は難しです。
もうひとつの方法は何回k-meansして、一番いい結果を使います。
2. ｋはハイパーパラメータなので、最適化する手段が少ない、殆ど人の経験で調整しています。

* その他
1. `2.4. グルプの中で、選び出す映画の評価の平均値を計算します。それを初期評価値にします。`
↑ その平均値計算する時、基準評価 (baseline rating) の違が考えていません。


2. 関係モデルですので、実際にユーザーとアイテムの関係がぜんぜん考えていません。関係モデルで推薦範囲を縮って、他の手法で最終の推薦結果を決めることも検討すべきです。
3. 評価する時間による影響を考えていません。評価時間によって重み付くことも検討すべきです。

参考資料
-----------------
1. [Winning the Netflix Prize: A Summary](http://blog.echen.me/2011/10/24/winning-the-netflix-prize-a-summary/)
2. [Introduction to behavior based recommendation system](https://www.slideshare.net/hamukazu/introduction-to-behavior-based-recommendation-system)
3. 「集合知プログラミング (*programming collective intelligence*)」,Toby Segaran, O'Reilly Media, August 2007
